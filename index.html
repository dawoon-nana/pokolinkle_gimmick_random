<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¸°ë¯¹ ëœë¤ ì¡°í•©</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23004B3E'/><path d='M20 30 L50 30 L50 20 L70 35 L50 50 L50 40 L20 40 Z' fill='white'/><path d='M80 70 L50 70 L50 80 L30 65 L50 50 L50 60 L80 60 Z' fill='white'/></svg>" type="image/svg+xml">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ffffff;
            min-height: 100vh;
            padding: 60px 40px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 80px;
        }
        h1 {
            color: #1a1a1a;
            font-size: 50px;
            font-weight: 700;
            margin-bottom: 16px;
            letter-spacing: -0.5px;
        }
        .tabs {
            display: flex;
            gap: 60px;
            margin-bottom: 60px;
            justify-content: center;
            border-bottom: 1px solid #e5e5e5;
        }
        .tab {
            padding: 20px 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: 600;
            color: #999;
            transition: all 0.3s;
            position: relative;
        }
        .tab:hover {
            color: #004B3E;
        }
        .tab.active {
            color: #004B3E;
        }
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 3px;
            background: #004B3E;
        }
        .content {
            display: none;
        }
        .content.active {
            display: block;
        }
        .refresh-btn {
            display: block;
            margin: 0 auto 60px;
            padding: 18px 60px;
            background: #004B3E;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .refresh-btn:hover {
            background: #003529;
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 75, 62, 0.2);
        }
        
        /* ëœë¤ ìŠ¤íƒ€ì¼ */
        .random-result {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 600px;
            margin: 0 auto;
        }
        .gimmick-card {
            background: #f8f9fa;
            padding: 28px;
            border-radius: 8px;
            text-align: center;
            color: #1a1a1a;
            font-size: 22px;
            font-weight: 600;
            border: 1px solid #e5e5e5;
            transition: all 0.3s;
        }
        .gimmick-card:hover {
            border-color: #004B3E;
            background: #f0f5f4;
        }
        
        /* ì…”í”Œ ìŠ¤íƒ€ì¼ */
        .shuffle-container {
            display: grid;
            grid-template-columns: 2.5fr 1fr;
            gap: 40px;
        }
        .combination-section {
            background: #ffffff;
        }
        .section-title {
            font-size: 26px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 30px;
            padding-bottom: 16px;
            border-bottom: 2px solid #004B3E;
        }
        .combo-block {
            background: #f8f9fa;
            padding: 24px;
            margin-bottom: 20px;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
            transition: all 0.3s;
        }
        .combo-block:hover {
            border-color: #004B3E;
            background: #f0f5f4;
        }
        .combo-item {
            padding: 12px 16px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            font-size: 16px;
            color: #1a1a1a;
            border: 1px solid #e5e5e5;
        }
        .failed-section {
            background: #ffffff;
        }
        .failed-title {
            font-size: 26px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 30px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e5e5e5;
        }
        .failed-item {
            padding: 14px 18px;
            margin: 12px 0;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 16px;
            color: #666;
            border: 1px solid #e5e5e5;
        }
        
        /* êµ¬ì„± ìŠ¤íƒ€ì¼ */
        .composition-levels {
            margin-bottom: 80px;
        }
        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }
        .level-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
        }
        .level-header {
            font-weight: 700;
            color: #004B3E;
            margin-bottom: 16px;
            text-align: center;
            font-size: 17px;
        }
        .level-gimmick {
            padding: 10px;
            margin: 6px 0;
            background: white;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
            color: #1a1a1a;
            border: 1px solid #e5e5e5;
        }
        
        /* í†µê³„ ìŠ¤íƒ€ì¼ */
        .stats-section {
            background: #f8f9fa;
            padding: 50px;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }
        .stats-title {
            font-size: 30px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 40px;
            text-align: center;
        }
        .stats-highlight {
            margin-bottom: 40px;
        }
        .stats-highlight-title {
            font-size: 19px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 20px;
        }
        .stats-highlight-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e5e5e5;
        }
        .stat-card.most {
            background: #91CCA4;
            border-color: #91CCA4;
        }
        .stat-name {
            font-size: 14px;
            margin-bottom: 12px;
        }
        .stat-card.most .stat-name {
            color: #004B3E;
            font-size: 15px;
            font-weight: 700;
        }
        .stat-card:not(.most) .stat-name {
            color: #666;
        }
        .stat-count {
            font-size: 30px;
            font-weight: 700;
        }
        .stat-card.most .stat-count {
            color: #004B3E;
            font-size: 31px;
        }
        .stat-card:not(.most) .stat-count {
            color: #004B3E;
        }
        .all-stats {
            background: white;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
        }
        .all-stats-title {
            font-size: 17px;
            font-weight: 600;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
        }
        .all-stats-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 12px;
            font-size: 15px;
        }
        .all-stat-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e5e5;
        }
        .all-stat-name {
            color: #666;
            margin-bottom: 6px;
        }
        .all-stat-count {
            font-weight: 700;
            color: #004B3E;
        }
        
        /* ìŠ¤í¬ë¡¤ ë²„íŠ¼ */
        .scroll-btn {
            position: fixed;
            right: 40px;
            background: #004B3E;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0, 75, 62, 0.3);
            transition: all 0.3s;
            z-index: 1000;
            display: none;
        }
        .scroll-btn:hover {
            background: #003529;
            transform: scale(1.1);
        }
        .scroll-top {
            bottom: 110px;
        }
        .scroll-bottom {
            bottom: 50px;
        }
        
        @media (max-width: 768px) {
            .shuffle-container {
                grid-template-columns: 1fr;
            }
            .level-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .stats-highlight-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            .all-stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ê¸°ë¯¹ ëœë¤ ì¡°í•©</h1>
        </header>
        
        <!-- íƒ­ -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('random')">ëœë¤ ì¶”ì¶œ</button>
            <button class="tab" onclick="showTab('shuffle')">ì…”í”Œ ì¡°í•©</button>
            <button class="tab" onclick="showTab('composition')">êµ¬ì„± ì¡°í•©</button>
        </div>
        
        <!-- ëœë¤ ì»¨í…ì¸  -->
        <div id="random" class="content active">
            <button class="refresh-btn" onclick="generateRandom()">ìƒˆë¡œ ë½‘ê¸°</button>
            <div id="randomResult" class="random-result"></div>
        </div>
        
        <!-- ì…”í”Œ ì»¨í…ì¸  -->
        <div id="shuffle" class="content">
            <button class="scroll-btn scroll-bottom" onclick="scrollToBottom()">â†“</button>
            <button class="scroll-btn scroll-top" onclick="scrollToTop()">â†‘</button>
            
            <button class="refresh-btn" onclick="generateShuffle()">ë‹¤ì‹œ ì„ê¸°</button>
            <div id="shuffleResult"></div>
        </div>
        
        <!-- êµ¬ì„± ì»¨í…ì¸  -->
        <div id="composition" class="content">
            <button class="scroll-btn scroll-bottom" onclick="scrollToBottom()">â†“</button>
            <button class="scroll-btn scroll-top" onclick="scrollToTop()">â†‘</button>
            
            <button class="refresh-btn" onclick="generateComposition()">50ê°œ ë ˆë²¨ ìƒì„±</button>
            <div id="compositionResult"></div>
        </div>
    </div>
    
    <script>
        // ê¸°ë¯¹ ë°ì´í„°
        const GIMMICKS = {
            point1: ['ì˜¤ë¸', 'í† ë¼í’€í™”ë‹¨', 'ë¸”ë¡ë°•ìŠ¤í­íƒ„', 'ì»¬ëŸ¬ë°•ìŠ¤', 'í”Œë¼ìŠ¤í¬', 'ë…¸ì´', 'ë©”ëª¨íŒ', 'ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤', 'ê³°ì¸í˜•ìƒì', 'ì‚¬íƒ•ë³‘', 'ì–‘í„¸'],
            point2: ['ë²„ë¸”ê½ƒ', 'í­íƒ„ì£¼ë¨¸ë‹ˆ', 'ì–‘í„¸ë°”êµ¬ë‹ˆ', 'ë²½ëŒ', 'ì˜¤ë¡œë¼ë²„ë¸”ê½ƒ', 'ë¨í”„', 'ì‚¬ë¬¼í•¨', 'ë¶„í™ê½ƒí™”ë¶„', 'ë¶„í™ì”ë””', 'ìº¡ìŠì˜¤ë¦¬'],
            normal: ['íƒë°°ë°•ìŠ¤', 'ì»µ', 'ì”ë””', 'í´ë¡œë²„ì„ìƒ', 'ì‚¬ê³¼', 'ì¹´í«', 'ë°¤', 'ì§„ì£¼ì¡°ê°œ', 'ì„íŒ']
        };
        
        // ë ˆë²¨ ì¬ìƒì„± í•¨ìˆ˜ (ì¸ì ‘ ë ˆë²¨ ê¸°ë¯¹ ì œì™¸)
        function regenerateLevel(allLevels, idx, comboMap = null) {
            console.log(`  ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì‹œë„...`);
            
            // ì¸ì ‘ ë ˆë²¨ ê¸°ë¯¹ ìˆ˜ì§‘ (ì•2, ë’¤1)
            const nearbyGimmicks = new Set();
            for (let offset of [-2, -1, 1]) {
                const nearIdx = idx + offset;
                if (nearIdx >= 0 && nearIdx < allLevels.length) {
                    allLevels[nearIdx].forEach(g => nearbyGimmicks.add(g));
                }
            }
            
            console.log(`    ì œì™¸í•  ê¸°ë¯¹ (ì¸ì ‘ ë ˆë²¨): ${Array.from(nearbyGimmicks).join(', ')}`);
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ë¯¹ í’€
            const availableGimmicks = [...GIMMICKS.normal, ...GIMMICKS.point1].filter(g => !nearbyGimmicks.has(g));
            
            if (availableGimmicks.length < 4) {
                console.log(`    âŒ ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ë¯¹ ë¶€ì¡± (${availableGimmicks.length}ê°œ)`);
                return false;
            }
            
            // ìµœëŒ€ 50ë²ˆ ì‹œë„
            for (let attempt = 0; attempt < 50; attempt++) {
                const newCombo = [];
                const shuffled = shuffleArray([...availableGimmicks]);
                
                for (let i = 0; i < Math.min(4, shuffled.length); i++) {
                    newCombo.push(shuffled[i]);
                }
                
                if (newCombo.length !== 4) continue;
                
                // 4-ì¡°í•© ì¤‘ë³µ ì²´í¬
                if (comboMap) {
                    const key = newCombo.slice().sort().join('|');
                    if (comboMap.has(key)) {
                        continue; // ì¤‘ë³µì´ë©´ ë‹¤ì‹œ ì‹œë„
                    }
                }
                
                // ì„±ê³µ
                allLevels[idx] = newCombo;
                
                // comboMap ì—…ë°ì´íŠ¸
                if (comboMap) {
                    const key = newCombo.slice().sort().join('|');
                    comboMap.set(key, idx);
                }
                
                console.log(`    âœ… ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì™„ë£Œ: [${newCombo.join(', ')}]`);
                return true;
            }
            
            console.log(`    âŒ ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì‹¤íŒ¨ (50ë²ˆ ì‹œë„)`);
            return false;
        }
        
        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        function safeClearConsole() {
            try {
                if (console.clear) {
                    console.clear();
                }
            } catch (e) {
                // console.clear ì§€ì› ì•ˆ í•˜ëŠ” í™˜ê²½
            }
        }
        
        // ì¶©ëŒí•˜ëŠ” ê¸°ë¯¹ë§Œ êµì²´ (ì„¸íŠ¸ ê·œì¹™ ì¤€ìˆ˜)
        function replaceConflictingGimmicks(allLevels, levelIdx, conflictingGimmicks) {
            console.log(`  ë ˆë²¨ ${levelIdx + 1}ì—ì„œ ì¶©ëŒ ê¸°ë¯¹ êµì²´ ì‹œë„: [${conflictingGimmicks.join(', ')}]`);
            
            const currentCombo = allLevels[levelIdx];
            
            // ì¸ì ‘ ë ˆë²¨ ê¸°ë¯¹ ìˆ˜ì§‘ (ì•2, ë’¤1)
            const nearbyGimmicks = new Set();
            for (let offset of [-2, -1, 1]) {
                const nearIdx = levelIdx + offset;
                if (nearIdx >= 0 && nearIdx < allLevels.length) {
                    allLevels[nearIdx].forEach(g => nearbyGimmicks.add(g));
                }
            }
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ë¯¹ (ì¸ì ‘ ë ˆë²¨ + í˜„ì¬ ì¡°í•© ì œì™¸)
            const availableGimmicks = [
                ...GIMMICKS.normal,
                ...GIMMICKS.point1,
                ...GIMMICKS.point2
            ].filter(g => !nearbyGimmicks.has(g) && !currentCombo.includes(g));
            
            console.log(`    ì‚¬ìš© ê°€ëŠ¥í•œ êµì²´ ê¸°ë¯¹: ${availableGimmicks.join(', ')}`);
            
            if (availableGimmicks.length === 0) {
                console.log(`    âŒ êµì²´ ê°€ëŠ¥í•œ ê¸°ë¯¹ ì—†ìŒ`);
                return false;
            }
            
            // ê° ì¶©ëŒ ê¸°ë¯¹ì„ êµì²´
            for (const conflictGimmick of conflictingGimmicks) {
                const gimmickIndex = currentCombo.indexOf(conflictGimmick);
                if (gimmickIndex === -1) continue;
                
                // ë¶„í™ì„¸íŠ¸ ì²´í¬: ë¶„í™ê½ƒí™”ë¶„ì´ë‚˜ ë¶„í™ì”ë””ë¥¼ ì œê±°í•˜ë ¤ê³  í•  ë•Œ
                if (conflictGimmick === 'ë¶„í™ê½ƒí™”ë¶„' || conflictGimmick === 'ë¶„í™ì”ë””') {
                    const hasPinkFlower = currentCombo.includes('ë¶„í™ê½ƒí™”ë¶„');
                    const hasPinkGrass = currentCombo.includes('ë¶„í™ì”ë””');
                    
                    if (hasPinkFlower && hasPinkGrass) {
                        // ë‘˜ ë‹¤ ìˆìœ¼ë©´ ë‘˜ ë‹¤ ì œê±°í•´ì•¼ í•¨
                        console.log(`    ë¶„í™ì„¸íŠ¸ ê°ì§€: ë¶„í™ê½ƒí™”ë¶„ê³¼ ë¶„í™ì”ë”” ëª¨ë‘ êµì²´`);
                        
                        // ë¶„í™ê½ƒí™”ë¶„ êµì²´
                        let replaced1 = false;
                        for (const newGimmick of shuffleArray(availableGimmicks)) {
                            const testCombo = [...currentCombo];
                            testCombo[currentCombo.indexOf('ë¶„í™ê½ƒí™”ë¶„')] = newGimmick;
                            if (canAddToCombo(testCombo.filter((g, i) => i !== currentCombo.indexOf('ë¶„í™ê½ƒí™”ë¶„')), newGimmick)) {
                                currentCombo[currentCombo.indexOf('ë¶„í™ê½ƒí™”ë¶„')] = newGimmick;
                                replaced1 = true;
                                break;
                            }
                        }
                        
                        // ë¶„í™ì”ë”” êµì²´
                        let replaced2 = false;
                        for (const newGimmick of shuffleArray(availableGimmicks)) {
                            if (currentCombo.includes(newGimmick)) continue;
                            const testCombo = [...currentCombo];
                            testCombo[currentCombo.indexOf('ë¶„í™ì”ë””')] = newGimmick;
                            if (canAddToCombo(testCombo.filter((g, i) => i !== currentCombo.indexOf('ë¶„í™ì”ë””')), newGimmick)) {
                                currentCombo[currentCombo.indexOf('ë¶„í™ì”ë””')] = newGimmick;
                                replaced2 = true;
                                break;
                            }
                        }
                        
                        if (!replaced1 || !replaced2) {
                            console.log(`    âŒ ë¶„í™ì„¸íŠ¸ êµì²´ ì‹¤íŒ¨`);
                            return false;
                        }
                        
                        allLevels[levelIdx] = currentCombo;
                        console.log(`    âœ… ë¶„í™ì„¸íŠ¸ êµì²´ ì™„ë£Œ: [${currentCombo.join(', ')}]`);
                        return true;
                    }
                }
                
                // ì¼ë°˜ ê¸°ë¯¹ êµì²´
                let replaced = false;
                const shuffledAvailable = shuffleArray(availableGimmicks);
                
                for (const newGimmick of shuffledAvailable) {
                    // ì´ë¯¸ ì¡°í•©ì— ìˆëŠ” ê¸°ë¯¹ì€ ì œì™¸
                    if (currentCombo.includes(newGimmick)) continue;
                    
                    // ì„ì‹œë¡œ êµì²´í•´ì„œ í…ŒìŠ¤íŠ¸
                    const testCombo = [...currentCombo];
                    testCombo[gimmickIndex] = newGimmick;
                    
                    // ì¶©ëŒ ê·œì¹™ ì²´í¬
                    if (!canAddToCombo(testCombo.filter((g, i) => i !== gimmickIndex), newGimmick)) {
                        continue;
                    }
                    
                    // ë¶„í™ì„¸íŠ¸ ê·œì¹™ ì²´í¬ (êµì²´ í›„ì—ë„ ì„¸íŠ¸ ìœ ì§€ë˜ëŠ”ì§€)
                    const hasPinkFlower = testCombo.includes('ë¶„í™ê½ƒí™”ë¶„');
                    const hasPinkGrass = testCombo.includes('ë¶„í™ì”ë””');
                    if (hasPinkFlower !== hasPinkGrass) {
                        continue; // ë¶„í™ì„¸íŠ¸ ê·œì¹™ ìœ„ë°˜
                    }
                    
                    // ì–‘í„¸ì„¸íŠ¸ ê·œì¹™ ì²´í¬
                    const hasWoolBasket = testCombo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ');
                    const hasWool = testCombo.includes('ì–‘í„¸');
                    if (hasWoolBasket && !hasWool) {
                        continue; // ì–‘í„¸ì„¸íŠ¸ ê·œì¹™ ìœ„ë°˜
                    }
                    
                    // êµì²´ ì„±ê³µ
                    currentCombo[gimmickIndex] = newGimmick;
                    replaced = true;
                    console.log(`    âœ… '${conflictGimmick}' â†’ '${newGimmick}'ë¡œ êµì²´`);
                    break;
                }
                
                if (!replaced) {
                    console.log(`    âŒ '${conflictGimmick}' êµì²´ ì‹¤íŒ¨`);
                    return false;
                }
            }
            
            allLevels[levelIdx] = currentCombo;
            console.log(`    âœ… ìµœì¢… ì¡°í•©: [${currentCombo.join(', ')}]`);
            return true;
        }
        
        // í•œ ë ˆë²¨ë§Œ ì¬ìƒì„± (ì¸ì ‘ ë ˆë²¨ ê¸°ë¯¹ ì œì™¸)
        function regenerateLevel(allLevels, idx, existingCombos = new Map()) {
            console.log(`  ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì‹œë„...`);
            
            // ì• 2ë ˆë²¨, ë’¤ 1ë ˆë²¨ì˜ ê¸°ë¯¹ ìˆ˜ì§‘
            const nearbyGimmicks = new Set();
            for (let offset of [-2, -1, 1]) {
                const nearIdx = idx + offset;
                if (nearIdx >= 0 && nearIdx < allLevels.length) {
                    allLevels[nearIdx].forEach(g => nearbyGimmicks.add(g));
                }
            }
            
            console.log(`    ì œì™¸í•  ê¸°ë¯¹ (ì¸ì ‘ ë ˆë²¨): ${Array.from(nearbyGimmicks).join(', ')}`);
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ë¯¹
            const availableGimmicks = [
                ...GIMMICKS.normal,
                ...GIMMICKS.point1,
                ...GIMMICKS.point2
            ].filter(g => !nearbyGimmicks.has(g));
            
            if (availableGimmicks.length < 4) {
                console.log(`    âŒ ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ë¯¹ ë¶€ì¡± (${availableGimmicks.length}ê°œ)`);
                return false; // null ëŒ€ì‹  false ë°˜í™˜
            }
            
            // ìµœëŒ€ 50ë²ˆ ì‹œë„
            for (let attempt = 0; attempt < 50; attempt++) {
                const shuffled = shuffleArray([...availableGimmicks]);
                const newCombo = shuffled.slice(0, 4);
                
                // ì¶©ëŒ ê·œì¹™ ì²´í¬ (ê° ê¸°ë¯¹ì´ ì„œë¡œ ì¶©ëŒí•˜ì§€ ì•ŠëŠ”ì§€)
                let hasConflict = false;
                for (let i = 0; i < newCombo.length; i++) {
                    if (!canAddToCombo(newCombo.filter((g, idx) => idx !== i), newCombo[i])) {
                        hasConflict = true;
                        break;
                    }
                }
                if (hasConflict) continue;
                
                // ì„¸íŠ¸ ê·œì¹™ ì²´í¬
                const hasPinkFlower = newCombo.includes('ë¶„í™ê½ƒí™”ë¶„');
                const hasPinkGrass = newCombo.includes('ë¶„í™ì”ë””');
                if (hasPinkFlower !== hasPinkGrass) {
                    continue; // ë¶„í™ì„¸íŠ¸ ê·œì¹™ ìœ„ë°˜
                }
                
                const hasWoolBasket = newCombo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ');
                const hasWool = newCombo.includes('ì–‘í„¸');
                if (hasWoolBasket && !hasWool) {
                    continue; // ì–‘í„¸ì„¸íŠ¸ ê·œì¹™ ìœ„ë°˜
                }
                
                // 4-ì¡°í•© ì¤‘ë³µ ì²´í¬
                const key = newCombo.slice().sort().join('|');
                if (!existingCombos.has(key)) {
                    allLevels[idx] = newCombo; // âœ… ì§ì ‘ ì—…ë°ì´íŠ¸!
                    existingCombos.set(key, idx); // âœ… Mapë„ ì—…ë°ì´íŠ¸!
                    console.log(`    âœ… ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì„±ê³µ: [${newCombo.join(', ')}]`);
                    return true; // ì„±ê³µ
                }
            }
            
            console.log(`    âŒ ë ˆë²¨ ${idx + 1} ì¬ìƒì„± ì‹¤íŒ¨ (50ë²ˆ ì‹œë„)`);
            return false; // ì‹¤íŒ¨
        }
        
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }
        
        function canAddToCombo(combo, gimmick) {
            const bubbles = ['í”Œë¼ìŠ¤í¬', 'ì˜¤ë¡œë¼ë²„ë¸”ê½ƒ', 'ë²„ë¸”ê½ƒ'];
            if (bubbles.includes(gimmick) && combo.some(g => bubbles.includes(g))) {
                return false;
            }
            
            if (gimmick === 'ë…¸ì´' && combo.includes('ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤')) return false;
            if (gimmick === 'ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤' && combo.includes('ë…¸ì´')) return false;
            
            // ìº¡ìŠì˜¤ë¦¬ â†” ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤ ì¶©ëŒ
            if (gimmick === 'ìº¡ìŠì˜¤ë¦¬' && combo.includes('ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤')) return false;
            if (gimmick === 'ìº¡ìŠì˜¤ë¦¬ë°•ìŠ¤' && combo.includes('ìº¡ìŠì˜¤ë¦¬')) return false;
            
            const carpetIncompatible = ['ì”ë””', 'ë¶„í™ì”ë””', 'ë¶„í™ê½ƒí™”ë¶„', 'ì„íŒ', 'í† ë¼í’€í™”ë‹¨'];
            if (gimmick === 'ì¹´í«' && combo.some(g => carpetIncompatible.includes(g))) return false;
            if (combo.includes('ì¹´í«') && carpetIncompatible.includes(gimmick)) return false;
            
            // ë¶„í™ ê¸°ë¯¹ ì¶©ëŒ
            const pinkIncompatible = ['ì¹´í«', 'ì”ë””', 'ì„íŒ'];
            if ((gimmick === 'ë¶„í™ê½ƒí™”ë¶„' || gimmick === 'ë¶„í™ì”ë””') && combo.some(g => pinkIncompatible.includes(g))) return false;
            if ((combo.includes('ë¶„í™ê½ƒí™”ë¶„') || combo.includes('ë¶„í™ì”ë””')) && pinkIncompatible.includes(gimmick)) return false;
            
            return true;
        }
        
        // ëœë¤ ì¶”ì¶œ
        function generateRandom() {
            safeClearConsole(); // ì•ˆì „í•˜ê²Œ ì½˜ì†” í´ë¦¬ì–´
            const allGimmicks = [...GIMMICKS.point1, ...GIMMICKS.point2, ...GIMMICKS.normal];
            let result = null;
            let attempts = 0;
            
            while (!result && attempts < 100) {
                result = tryGenerateRandomCombo(allGimmicks);
                attempts++;
            }
            
            displayRandomResult(result || ['ì¡°í•© ìƒì„± ì‹¤íŒ¨']);
        }
        
        function tryGenerateRandomCombo(allGimmicks) {
            const shuffled = shuffleArray(allGimmicks);
            const combo = [];
            const used = new Set();
            let maxSize = 4;
            
            for (let i = 0; i < shuffled.length && combo.length < maxSize; i++) {
                if (used.has(i)) continue;
                
                const current = shuffled[i];
                
                if (!canAddToCombo(combo, current)) continue;
                
                combo.push(current);
                used.add(i);
                
                if (current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') maxSize = 5;
                
                // ì„¸íŠ¸ ì°¾ê¸°
                if (current === 'ë¶„í™ê½ƒí™”ë¶„' && !combo.includes('ë¶„í™ì”ë””')) {
                    const idx = shuffled.findIndex((g, j) => !used.has(j) && g === 'ë¶„í™ì”ë””');
                    if (idx !== -1 && combo.length < maxSize) {
                        combo.push('ë¶„í™ì”ë””');
                        used.add(idx);
                    } else {
                        combo.pop();
                        used.delete(i);
                        continue;
                    }
                }
                
                if (current === 'ë¶„í™ì”ë””' && !combo.includes('ë¶„í™ê½ƒí™”ë¶„')) {
                    const idx = shuffled.findIndex((g, j) => !used.has(j) && g === 'ë¶„í™ê½ƒí™”ë¶„');
                    if (idx !== -1 && combo.length < maxSize) {
                        combo.push('ë¶„í™ê½ƒí™”ë¶„');
                        used.add(idx);
                    } else {
                        combo.pop();
                        used.delete(i);
                        continue;
                    }
                }
                
                if (current === 'ì–‘í„¸ë°”êµ¬ë‹ˆ' && !combo.includes('ì–‘í„¸')) {
                    const idx = shuffled.findIndex((g, j) => !used.has(j) && g === 'ì–‘í„¸');
                    if (idx !== -1 && combo.length < maxSize) {
                        combo.push('ì–‘í„¸');
                        used.add(idx);
                    } else {
                        combo.pop();
                        used.delete(i);
                        continue;
                    }
                }
            }
            
            return combo.length >= 4 ? combo : null;
        }
        
        function displayRandomResult(result) {
            const container = document.getElementById('randomResult');
            container.innerHTML = result.map(g => `<div class="gimmick-card">${g}</div>`).join('');
        }
        
        // ì…”í”Œ ì¡°í•©
        function generateShuffle() {
            safeClearConsole(); // ì•ˆì „í•˜ê²Œ ì½˜ì†” í´ë¦¬ì–´
            const allGimmicks = [...GIMMICKS.point1, ...GIMMICKS.point2, ...GIMMICKS.normal];
            const shuffled = shuffleArray(allGimmicks);
            const used = new Array(shuffled.length).fill(false);
            const yangUsed = new Set();
            let yangAloneUsed = false;
            let yangWithBasketUsed = false;
            const combinations = [];
            let currentIdx = 0;
            
            while (currentIdx < shuffled.length) {
                while (currentIdx < shuffled.length && used[currentIdx]) currentIdx++;
                if (currentIdx >= shuffled.length) break;
                
                const combo = [];
                const indices = [];
                let maxSize = 4;
                
                // ë‚¨ì€ ê¸°ë¯¹ ê°œìˆ˜ í™•ì¸
                const remaining = shuffled.filter((g, i) => !used[i] && (g !== 'ì–‘í„¸' || !yangUsed.has(i)));
                
                for (let j = currentIdx; j < shuffled.length; j++) {
                    if (!used[j] && !indices.includes(j)) {
                        const current = shuffled[j];
                        
                        if (current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ' && maxSize < 5) maxSize = 5;
                        if (!canAddToCombo(combo, current)) continue;
                        
                        // ì–‘í„¸ ë‹¨ë… ì‚¬ìš© ì œí•œ
                        if (current === 'ì–‘í„¸') {
                            if (yangWithBasketUsed) continue;
                            if (yangAloneUsed && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) continue;
                        }
                        
                        // ë‚¨ì€ ê¸°ë¯¹ì´ 4ê°œ ë¯¸ë§Œì´ê³  í˜„ì¬ê°€ í­íƒ„ì£¼ë¨¸ë‹ˆë©´ ë‚˜ì¤‘ì— ì¶”ê°€
                        if (remaining.length < 4 && current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') continue;
                        
                        if (combo.length >= maxSize) break;
                        
                        // ë¨¼ì € comboì™€ indicesì— ì¶”ê°€
                        combo.push(current);
                        indices.push(j);
                        
                        if (current === 'ì–‘í„¸' && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) {
                            yangUsed.add(j);
                        }
                        
                        // ì–‘í„¸ë°”êµ¬ë‹ˆ ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ì–‘í„¸ë°”êµ¬ë‹ˆ' && !combo.includes('ì–‘í„¸') && !yangWithBasketUsed) {
                            if (combo.length < 4) {
                                let foundYang = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!indices.includes(k) && !used[k] && shuffled[k] === 'ì–‘í„¸') {
                                        combo.push('ì–‘í„¸');
                                        indices.push(k);
                                        yangUsed.add(k);
                                        yangWithBasketUsed = true;
                                        foundYang = true;
                                        break;
                                    }
                                }
                                if (!foundYang) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                        
                        // ë¶„í™ê½ƒí™”ë¶„ ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ë¶„í™ê½ƒí™”ë¶„' && !combo.includes('ë¶„í™ì”ë””')) {
                            if (combo.length < 4) {
                                let foundPinkGrass = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!used[k] && !indices.includes(k) && shuffled[k] === 'ë¶„í™ì”ë””') {
                                        combo.push('ë¶„í™ì”ë””');
                                        indices.push(k);
                                        foundPinkGrass = true;
                                        break;
                                    }
                                }
                                if (!foundPinkGrass) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                        
                        // ë¶„í™ì”ë”” ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ë¶„í™ì”ë””' && !combo.includes('ë¶„í™ê½ƒí™”ë¶„')) {
                            if (combo.length < 4) {
                                let foundPinkFlower = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!used[k] && !indices.includes(k) && shuffled[k] === 'ë¶„í™ê½ƒí™”ë¶„') {
                                        combo.push('ë¶„í™ê½ƒí™”ë¶„');
                                        indices.push(k);
                                        foundPinkFlower = true;
                                        break;
                                    }
                                }
                                if (!foundPinkFlower) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                    }
                }
                
                // ë‚¨ì€ ê¸°ë¯¹ì´ 4ê°œ ë¯¸ë§Œì´ë©´ í­íƒ„ì£¼ë¨¸ë‹ˆ ì¶”ê°€
                if (remaining.length < 4 && combo.length < 5) {
                    for (let j = 0; j < shuffled.length; j++) {
                        if (!used[j] && shuffled[j] === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') {
                            combo.push('í­íƒ„ì£¼ë¨¸ë‹ˆ');
                            indices.push(j);
                            break;
                        }
                    }
                }
                
                if (combo.length < 4) break;
                
                if (combo.includes('ì–‘í„¸') && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) {
                    yangAloneUsed = true;
                }
                
                if (combo.length >= 4) {
                    combinations.push(combo);
                    for (const idx of indices) {
                        if (shuffled[idx] !== 'ì–‘í„¸') {
                            used[idx] = true;
                        }
                    }
                }
                currentIdx++;
            }
            
            const failed = [];
            for (let i = 0; i < shuffled.length; i++) {
                if (shuffled[i] === 'ì–‘í„¸') {
                    if (!yangUsed.has(i)) failed.push(shuffled[i]);
                } else {
                    if (!used[i]) failed.push(shuffled[i]);
                }
            }
            
            displayShuffleResult(combinations, failed);
        }
        
        function displayShuffleResult(combinations, failed) {
            const container = document.getElementById('shuffleResult');
            let html = '<div class="shuffle-container">';
            html += '<div class="combination-section"><div class="section-title">ì¡°í•© ì„±ê³µ</div>';
            
            combinations.forEach(combo => {
                html += '<div class="combo-block">';
                combo.forEach(g => {
                    html += `<div class="combo-item">${g}</div>`;
                });
                html += '</div>';
            });
            
            html += '</div><div class="failed-section"><div class="failed-title">ì¡°í•© ì‹¤íŒ¨</div>';
            failed.forEach(g => {
                html += `<div class="failed-item">${g}</div>`;
            });
            html += '</div></div>';
            
            container.innerHTML = html;
        }
        
        // êµ¬ì„± ì¡°í•© (50ê°œ ë ˆë²¨) - ë¸”ë¡ë³„ ë…ë¦½ ìƒì„±
        function generateComposition() {
            safeClearConsole(); // ì•ˆì „í•˜ê²Œ ì½˜ì†” í´ë¦¬ì–´
            
            // ìƒì„± ì„¸ì…˜ êµ¬ë¶„
            const timestamp = new Date().toLocaleString('ko-KR');
            console.log('\n\n');
            console.log('='.repeat(60));
            console.log(`ğŸ² ìƒˆë¡œìš´ ìƒì„± ì‹œì‘ - ${timestamp}`);
            console.log('='.repeat(60));
            console.log('ë°©ì‹: ë¸”ë¡ë³„ ë…ë¦½ ìƒì„± (5ë¸”ë¡ Ã— 10ë ˆë²¨)\n');
            
            const allLevels = [];
            let totalSuccess = true;
            
            // 5ê°œ ë¸”ë¡ ìƒì„± (ê° ë¸”ë¡ë³„ë¡œ ì¬ì‹œë„)
            for (let blockIdx = 0; blockIdx < 5; blockIdx++) {
                let blockSuccess = false;
                let blockAttempt = 0;
                const maxBlockAttempts = 20;
                
                while (!blockSuccess && blockAttempt < maxBlockAttempts) {
                    blockAttempt++;
                    
                    if (blockAttempt > 1) {
                        console.log(`\nâš ï¸ ë¸”ë¡ ${blockIdx + 1} ì¬ì‹œë„ ${blockAttempt}/${maxBlockAttempts}...`);
                    } else {
                        console.log(`\në¸”ë¡ ${blockIdx + 1} ìƒì„± ì¤‘...`);
                    }
                    
                    const blockLevels = generateOneBlock();
                    if (!blockLevels) {
                        console.log(`âŒ ë¸”ë¡ ${blockIdx + 1} ìƒì„± ì‹¤íŒ¨`);
                        continue;
                    }
                    
                    // ì„ì‹œë¡œ allLevelsì— ì¶”ê°€
                    const tempAllLevels = [...allLevels, ...blockLevels];
                    
                    // 2ë¸”ë¡ë¶€í„°: ë¸”ë¡ ê°„ ì¸ì ‘ ë ˆë²¨ ì²´í¬ ë° êµì²´
                    if (blockIdx >= 1) {
                        const fixed = checkAndFixBlockBoundary(tempAllLevels, blockIdx);
                        if (!fixed) {
                            console.log(`âŒ ë¸”ë¡ ${blockIdx + 1} ê²½ê³„ ì²´í¬ ì‹¤íŒ¨`);
                            continue;
                        }
                        
                        // ë¸”ë¡ ê²½ê³„ ì²´í¬ í›„ í˜„ì¬ ë¸”ë¡ ìµœì¢… í™•ì¸
                        console.log(`\n=== ë¸”ë¡ ${blockIdx + 1} ìµœì¢… í™•ì¸ (ê²½ê³„ ì²´í¬ ì™„ë£Œ) ===`);
                        const currentBlockStart = blockIdx * 10;
                        for (let i = 0; i < 10; i++) {
                            const levelNum = currentBlockStart + i + 1;
                            const combo = tempAllLevels[currentBlockStart + i];
                            console.log(`ë ˆë²¨ ${levelNum}: [${combo.join(', ')}]`);
                        }
                        
                        // ì„±ê³µ: allLevels ì—…ë°ì´íŠ¸ (ê²½ê³„ ì²´í¬ë¡œ ìˆ˜ì •ëœ tempAllLevels ë°˜ì˜)
                        allLevels.length = 0;
                        allLevels.push(...tempAllLevels);
                    } else {
                        // ë¸”ë¡ 1: ê²½ê³„ ì²´í¬ ì—†ì´ ë°”ë¡œ ì¶”ê°€
                        allLevels.push(...blockLevels);
                    }
                    
                    blockSuccess = true;
                    console.log(`âœ… ë¸”ë¡ ${blockIdx + 1} ì™„ë£Œ (í˜„ì¬ ${allLevels.length}ê°œ ë ˆë²¨)`);
                }
                
                if (!blockSuccess) {
                    console.log(`\nâŒ ë¸”ë¡ ${blockIdx + 1} ìµœì¢… ì‹¤íŒ¨ (${maxBlockAttempts}ë²ˆ ì‹œë„)`);
                    totalSuccess = false;
                    break;
                }
            }
            
            if (!totalSuccess) {
                console.log('\nâŒ 50ê°œ ë ˆë²¨ ìƒì„± ìµœì¢… ì‹¤íŒ¨');
                alert('50ê°œ ë ˆë²¨ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            console.log('\n4-ì¡°í•© ì¤‘ë³µ ì²´í¬ ì¤‘...');
            
            // 4-ì¡°í•© ì¤‘ë³µ ì²´í¬ ë° êµì²´ (ìµœëŒ€ 5ë²ˆ ì‹œë„)
            let finalLevels = null;
            let duplicateCheckAttempt = 0;
            const maxDuplicateAttempts = 5;
            
            while (!finalLevels && duplicateCheckAttempt < maxDuplicateAttempts) {
                duplicateCheckAttempt++;
                
                if (duplicateCheckAttempt > 1) {
                    console.log(`\nâš ï¸ ì¤‘ë³µ ì²´í¬ ì¬ì‹œë„ ${duplicateCheckAttempt}/${maxDuplicateAttempts}`);
                }
                
                const result = checkAndReplaceDuplicatesWithBlockInfo(allLevels);
                
                if (result.success) {
                    finalLevels = result.levels;
                    break;
                }
                
                // ì‹¤íŒ¨: ì¤‘ë³µëœ ë ˆë²¨ì´ ì†í•œ ë¸”ë¡ë“¤ë§Œ ì¬ìƒì„±
                if (result.duplicateBlocks && result.duplicateBlocks.length > 0) {
                    // ë¸”ë¡ì„ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (ì•ì—ì„œë¶€í„° ì¬ìƒì„±)
                    const sortedBlocks = [...result.duplicateBlocks].sort((a, b) => a - b);
                    console.log(`âŒ ì¤‘ë³µ êµì²´ ì‹¤íŒ¨ â†’ ë¸”ë¡ ${sortedBlocks.map(b => b + 1).join(', ')} ì¬ìƒì„±`);
                    
                    // ì¤‘ë³µëœ ë¸”ë¡ë“¤ë§Œ ì¬ìƒì„±
                    let allBlocksSuccess = true;
                    
                    for (const blockIdx of sortedBlocks) {
                        let blockSuccess = false;
                        let blockAttempt = 0;
                        
                        while (!blockSuccess && blockAttempt < 10) {
                            blockAttempt++;
                            console.log(`  ë¸”ë¡ ${blockIdx + 1} ì¬ìƒì„± ì‹œë„ ${blockAttempt}/10...`);
                            
                            const blockLevels = generateOneBlock();
                            if (!blockLevels) {
                                continue;
                            }
                            
                            // í•´ë‹¹ ë¸”ë¡ë§Œ êµì²´
                            const tempAllLevels = [...allLevels];
                            for (let i = 0; i < 10; i++) {
                                tempAllLevels[blockIdx * 10 + i] = blockLevels[i];
                            }
                            
                            // ë¸”ë¡ ê²½ê³„ ì²´í¬ (ì´ì „ ë¸”ë¡ê³¼)
                            if (blockIdx >= 1) {
                                const fixed = checkAndFixBlockBoundary(tempAllLevels, blockIdx);
                                if (!fixed) {
                                    continue;
                                }
                            }
                            
                            // ë¸”ë¡ ê²½ê³„ ì²´í¬ (ë‹¤ìŒ ë¸”ë¡ê³¼) - ë‹¤ìŒ ë¸”ë¡ì´ ì¬ìƒì„± ëŒ€ìƒì´ ì•„ë‹ ë•Œë§Œ
                            if (blockIdx < 4 && !sortedBlocks.includes(blockIdx + 1)) {
                                const fixed = checkAndFixBlockBoundary(tempAllLevels, blockIdx + 1);
                                if (!fixed) {
                                    continue;
                                }
                            }
                            
                            // ì„±ê³µ: tempAllLevelsë¥¼ allLevelsë¡œ ì™„ì „íˆ êµì²´
                            allLevels.length = 0;
                            allLevels.push(...tempAllLevels);
                            blockSuccess = true;
                            console.log(`  âœ… ë¸”ë¡ ${blockIdx + 1} ì¬ìƒì„± ì™„ë£Œ`);
                        }
                        
                        if (!blockSuccess) {
                            console.log(`  âŒ ë¸”ë¡ ${blockIdx + 1} ì¬ìƒì„± ì‹¤íŒ¨`);
                            allBlocksSuccess = false;
                            break;
                        }
                    }
                    
                    if (!allBlocksSuccess) {
                        console.log('âŒ ë¸”ë¡ ì¬ìƒì„± ì‹¤íŒ¨');
                        break;
                    }
                } else {
                    console.log('âŒ ì¤‘ë³µ êµì²´ ì‹¤íŒ¨ (êµì²´ ê°€ëŠ¥í•œ ì¡°í•© ì—†ìŒ)');
                    break;
                }
            }
            
            if (!finalLevels) {
                console.log(`\nâŒ ì¤‘ë³µ ì œê±° ìµœì¢… ì‹¤íŒ¨ (${maxDuplicateAttempts}ë²ˆ ì‹œë„)`);
                alert('ì¤‘ë³µ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            console.log('âœ… 50ê°œ ë ˆë²¨ ëª¨ë‘ ìƒì„± ì™„ë£Œ!');
            
            // ìµœì¢… 50ê°œ ë ˆë²¨ ì „ì²´ ì¶œë ¥ (ëª¨ë“  ìˆ˜ì • ì™„ë£Œ)
            console.log('\n' + '='.repeat(60));
            console.log('âœ… ìµœì¢… 50ê°œ ë ˆë²¨ (ì¤‘ë³µ ì œê±° ì™„ë£Œ)');
            console.log('ğŸ“‹ ì´ ê²°ê³¼ê°€ í™”ë©´ì— í‘œì‹œë©ë‹ˆë‹¤');
            console.log('='.repeat(60));
            for (let i = 0; i < 5; i++) {
                console.log(`\n[ ë¸”ë¡ ${i + 1} (ë ˆë²¨ ${i*10+1}-${i*10+10}) ]`);
                for (let j = 0; j < 10; j++) {
                    const levelNum = i * 10 + j + 1;
                    const combo = finalLevels[i * 10 + j];
                    console.log(`  ë ˆë²¨ ${levelNum}: [${combo.join(', ')}]`);
                }
            }
            console.log('\n' + '='.repeat(60));
            console.log('âœ… ìƒì„± ì™„ë£Œ!');
            console.log('='.repeat(60) + '\n\n');
            
            // í†µê³„ ê³„ì‚°
            const stats = {};
            const allGimmicks = [...GIMMICKS.point1, ...GIMMICKS.point2, ...GIMMICKS.normal];
            allGimmicks.forEach(g => stats[g] = 0);
            finalLevels.forEach(combo => {
                combo.forEach(g => stats[g]++);
            });
            
            displayCompositionResult(finalLevels, stats);
        }
        
        // ë¸”ë¡ 1ê°œ ìƒì„± (10ê°œ ë ˆë²¨)
        function generateOneBlock() {
            const allGimmicks = [...GIMMICKS.point1, ...GIMMICKS.point2, ...GIMMICKS.normal];
            
            // 1ë‹¨ê³„: ì…”í”Œ ì¡°í•© ë°©ì‹ ê·¸ëŒ€ë¡œ ì ìš© (ì•½ 7ê°œ ì¡°í•© ìƒì„±)
            const shuffled = shuffleArray(allGimmicks);
            const used = new Array(shuffled.length).fill(false);
            const yangUsed = new Set();
            let yangAloneUsed = false;
            let yangWithBasketUsed = false;
            const blockCombos = [];
            let currentIdx = 0;
            
            while (currentIdx < shuffled.length) {
                while (currentIdx < shuffled.length && used[currentIdx]) currentIdx++;
                if (currentIdx >= shuffled.length) break;
                
                const combo = [];
                const indices = [];
                let maxSize = 4;
                
                const remaining = shuffled.filter((g, i) => !used[i] && (g !== 'ì–‘í„¸' || !yangUsed.has(i)));
                
                for (let j = currentIdx; j < shuffled.length; j++) {
                    if (!used[j] && !indices.includes(j)) {
                        const current = shuffled[j];
                        
                        if (current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ' && maxSize < 5) maxSize = 5;
                        if (!canAddToCombo(combo, current)) continue;
                        
                        if (current === 'ì–‘í„¸') {
                            if (yangWithBasketUsed) continue;
                            if (yangAloneUsed && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) continue;
                        }
                        
                        if (remaining.length < 4 && current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') continue;
                        if (combo.length >= maxSize) break;
                        
                        combo.push(current);
                        indices.push(j);
                        
                        if (current === 'ì–‘í„¸' && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) {
                            yangUsed.add(j);
                        }
                        
                        // ì–‘í„¸ë°”êµ¬ë‹ˆ ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ì–‘í„¸ë°”êµ¬ë‹ˆ' && !combo.includes('ì–‘í„¸') && !yangWithBasketUsed) {
                            if (combo.length < 4) {
                                let foundYang = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!indices.includes(k) && !used[k] && shuffled[k] === 'ì–‘í„¸') {
                                        combo.push('ì–‘í„¸');
                                        indices.push(k);
                                        yangUsed.add(k);
                                        yangWithBasketUsed = true;
                                        foundYang = true;
                                        break;
                                    }
                                }
                                if (!foundYang) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                        
                        // ë¶„í™ê½ƒí™”ë¶„ ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ë¶„í™ê½ƒí™”ë¶„' && !combo.includes('ë¶„í™ì”ë””')) {
                            if (combo.length < 4) {
                                let foundPinkGrass = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!used[k] && !indices.includes(k) && shuffled[k] === 'ë¶„í™ì”ë””') {
                                        combo.push('ë¶„í™ì”ë””');
                                        indices.push(k);
                                        foundPinkGrass = true;
                                        break;
                                    }
                                }
                                if (!foundPinkGrass) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                        
                        // ë¶„í™ì”ë”” ì„¸íŠ¸ ì°¾ê¸°
                        if (current === 'ë¶„í™ì”ë””' && !combo.includes('ë¶„í™ê½ƒí™”ë¶„')) {
                            if (combo.length < 4) {
                                let foundPinkFlower = false;
                                for (let k = 0; k < shuffled.length; k++) {
                                    if (!used[k] && !indices.includes(k) && shuffled[k] === 'ë¶„í™ê½ƒí™”ë¶„') {
                                        combo.push('ë¶„í™ê½ƒí™”ë¶„');
                                        indices.push(k);
                                        foundPinkFlower = true;
                                        break;
                                    }
                                }
                                if (!foundPinkFlower) {
                                    combo.pop();
                                    indices.pop();
                                    continue;
                                }
                            } else {
                                combo.pop();
                                indices.pop();
                                continue;
                            }
                        }
                    }
                }
                
                // ë‚¨ì€ ê¸°ë¯¹ì´ 4ê°œ ë¯¸ë§Œì´ë©´ í­íƒ„ì£¼ë¨¸ë‹ˆ ì¶”ê°€
                const remainingCheck = shuffled.filter((g, i) => !used[i] && (g !== 'ì–‘í„¸' || !yangUsed.has(i)));
                if (remainingCheck.length < 4 && combo.length < 5) {
                    for (let j = 0; j < shuffled.length; j++) {
                        if (!used[j] && shuffled[j] === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') {
                            combo.push('í­íƒ„ì£¼ë¨¸ë‹ˆ');
                            indices.push(j);
                            break;
                        }
                    }
                }
                
                if (combo.length < 4) break;
                
                if (combo.includes('ì–‘í„¸') && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) {
                    yangAloneUsed = true;
                }
                
                if (combo.length >= 4) {
                    blockCombos.push(combo);
                    for (const idx of indices) {
                        if (shuffled[idx] !== 'ì–‘í„¸') {
                            used[idx] = true;
                        }
                    }
                }
                currentIdx++;
            }
            
            // í­íƒ„ì£¼ë¨¸ë‹ˆ íŠ¹ë³„ ê·œì¹™: ë‚¨ì€ ê¸°ë¯¹ì— í­íƒ„ì£¼ë¨¸ë‹ˆê°€ ìˆìœ¼ë©´ ë§ˆì§€ë§‰ ì¡°í•©ì— ê°•ì œ ì¶”ê°€
            const tempRemaining = [];
            for (let i = 0; i < shuffled.length; i++) {
                if (shuffled[i] === 'ì–‘í„¸') {
                    if (!yangUsed.has(i)) {
                        tempRemaining.push(shuffled[i]);
                    }
                } else {
                    if (!used[i]) {
                        tempRemaining.push(shuffled[i]);
                    }
                }
            }
            
            if (tempRemaining.includes('í­íƒ„ì£¼ë¨¸ë‹ˆ') && blockCombos.length > 0) {
                const lastCombo = blockCombos[blockCombos.length - 1];
                if (lastCombo.length < 5) {
                    lastCombo.push('í­íƒ„ì£¼ë¨¸ë‹ˆ');
                }
            }
            
            // ì‹¤ì œë¡œ ì‚¬ìš©ëœ ê¸°ë¯¹ ê³„ì‚° (blockCombos ê¸°ì¤€)
            const usedGimmicks = new Set();
            blockCombos.forEach(combo => {
                combo.forEach(g => usedGimmicks.add(g));
            });
            
            // ë‚¨ì€ ê¸°ë¯¹ = ì „ì²´ - ì‚¬ìš©ëœ ê²ƒ
            const remainingGimmicks = allGimmicks.filter(g => !usedGimmicks.has(g));
            
            console.log(`\n1ë‹¨ê³„ ì™„ë£Œ: ${blockCombos.length}ê°œ ì¡°í•©`);
            console.log(`=== 1ë‹¨ê³„ ìƒì„±ëœ ì¡°í•©ë“¤ ===`);
            blockCombos.forEach((combo, idx) => {
                console.log(`  ì¡°í•© ${idx + 1}: [${combo.join(', ')}]`);
            });
            console.log(`\nì‚¬ìš©ëœ ê¸°ë¯¹ ${usedGimmicks.size}ê°œ: [${[...usedGimmicks].join(', ')}]`);
            console.log(`ë‚¨ì€ ê¸°ë¯¹ ${remainingGimmicks.length}ê°œ: [${remainingGimmicks.join(', ')}]`);
            
            if (blockCombos.length < 7) {
                console.log('1ë‹¨ê³„ ì‹¤íŒ¨: 7ê°œ ë¯¸ë§Œ ì¡°í•© ìƒì„±');
                return null;
            }
            
            // 2ë‹¨ê³„: ë‚¨ì€ ê¸°ë¯¹ ì‚¬ìš© + ë²”ìš©/í¬ì¸íŠ¸1ë¡œ 3ê°œ ì¡°í•© ì¶”ê°€
            console.log('\n2ë‹¨ê³„ ì‹œì‘: 3ê°œ ì¡°í•© ì¶”ê°€');
            
            // ì¡°í•© 8 ìƒì„±: ë‚¨ì€ ê¸°ë¯¹ ì™„ì „ ì†Œì§„ + (ì¡°í•©6,7ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1)
            const combo6 = blockCombos[blockCombos.length - 2];
            const combo7 = blockCombos[blockCombos.length - 1];
            const recentFromStep1 = [...combo6, ...combo7];
            console.log(`ì¡°í•© 6: [${combo6.join(', ')}]`);
            console.log(`ì¡°í•© 7: [${combo7.join(', ')}]`);
            console.log(`â†’ ì¡°í•© 8 ìƒì„± ì‹œ ì œì™¸í•  ê¸°ë¯¹: [${recentFromStep1.join(', ')}]`);
            
            const combo8 = generateCombo8(remainingGimmicks, recentFromStep1);
            if (!combo8) {
                console.log('âŒ ì¡°í•© 8 ìƒì„± ì‹¤íŒ¨');
                return null;
            }
            
            blockCombos.push(combo8);
            console.log(`âœ… ì¡°í•© 8: [${combo8.join(', ')}]`);
            
            // ì¡°í•© 9 ìƒì„±: (ì¡°í•©7,8ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1ë§Œ)
            const recentFor9 = [...combo7, ...combo8];
            console.log(`\nì¡°í•© 7: [${combo7.join(', ')}]`);
            console.log(`ì¡°í•© 8: [${combo8.join(', ')}]`);
            console.log(`â†’ ì¡°í•© 9 ìƒì„± ì‹œ ì œì™¸í•  ê¸°ë¯¹: [${recentFor9.join(', ')}]`);
            
            const combo9 = generateComboFromPool(recentFor9);
            if (!combo9) {
                console.log('âŒ ì¡°í•© 9 ìƒì„± ì‹¤íŒ¨');
                return null;
            }
            
            blockCombos.push(combo9);
            console.log(`âœ… ì¡°í•© 9: [${combo9.join(', ')}]`);
            
            // ì¡°í•© 10 ìƒì„±: (ì¡°í•©8,9ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1ë§Œ)
            const recentFor10 = [...combo8, ...combo9];
            console.log(`\nì¡°í•© 8: [${combo8.join(', ')}]`);
            console.log(`ì¡°í•© 9: [${combo9.join(', ')}]`);
            console.log(`â†’ ì¡°í•© 10 ìƒì„± ì‹œ ì œì™¸í•  ê¸°ë¯¹: [${recentFor10.join(', ')}]`);
            
            const combo10 = generateComboFromPool(recentFor10);
            if (!combo10) {
                console.log('âŒ ì¡°í•© 10 ìƒì„± ì‹¤íŒ¨');
                return null;
            }
            
            blockCombos.push(combo10);
            console.log(`âœ… ì¡°í•© 10: [${combo10.join(', ')}]`);
            
            console.log(`\n2ë‹¨ê³„ ì™„ë£Œ: ì´ ${blockCombos.length}ê°œ ì¡°í•©`);
            
            // ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì²´í¬
            console.log('\n=== ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì²´í¬ ===');
            const yangFixed = checkAndFixYangWoolProximity(blockCombos);
            if (!yangFixed) {
                console.log('ì–‘í„¸ ì¡°í•© ë¶„ë¦¬ ì‹¤íŒ¨');
                return null;
            }
            
            // 3ë‹¨ê³„: ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ (ì´ë¯¸ ìˆœì„œê°€ í•´ê²°ë˜ì–´ ìˆìŒ)
            console.log('\n3ë‹¨ê³„: ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ (ë¸”ë¡ ë‚´ë¶€ ì¡°í•©ì€ ì´ë¯¸ ìˆœì„œ í™•ì •)');
            
            // ìµœì¢… ìƒì„±ëœ 10ê°œ ì¡°í•© ì¶œë ¥ (ëª¨ë“  ìˆ˜ì • ì™„ë£Œ í›„)
            console.log('\n=== ë¸”ë¡ ìµœì¢… ì¡°í•© (ì–‘í„¸ ë¶„ë¦¬ ì™„ë£Œ) ===');
            blockCombos.forEach((combo, idx) => {
                console.log(`ì¡°í•© ${idx + 1}: [${combo.join(', ')}]`);
            });
            
            return blockCombos;
        }
        
        // ì¡°í•© 8 ìƒì„±: ë‚¨ì€ ê¸°ë¯¹ ì™„ì „ ì†Œì§„ + (ì¡°í•©6,7ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1)
        function generateCombo8(remainingGimmicks, recentGimmicks) {
            for (let attempt = 0; attempt < 100; attempt++) {
                const combo = [];
                let maxSize = 4;
                
                // ë‚¨ì€ ê¸°ë¯¹ ìš°ì„  ì¶”ê°€
                const shuffledRemaining = shuffleArray(remainingGimmicks);
                for (const g of shuffledRemaining) {
                    if (combo.length >= maxSize) break;
                    if (combo.includes(g)) continue;
                    if (!canAddToCombo(combo, g)) continue;
                    
                    // ì„¸íŠ¸ ì²˜ë¦¬
                    if (g === 'ì–‘í„¸ë°”êµ¬ë‹ˆ') {
                        if (remainingGimmicks.includes('ì–‘í„¸') && !combo.includes('ì–‘í„¸')) {
                            combo.push('ì–‘í„¸ë°”êµ¬ë‹ˆ', 'ì–‘í„¸');
                        }
                    } else if (g === 'ë¶„í™ê½ƒí™”ë¶„') {
                        if (remainingGimmicks.includes('ë¶„í™ì”ë””') && !combo.includes('ë¶„í™ì”ë””')) {
                            combo.push('ë¶„í™ê½ƒí™”ë¶„', 'ë¶„í™ì”ë””');
                        }
                    } else if (g === 'ë¶„í™ì”ë””') {
                        if (remainingGimmicks.includes('ë¶„í™ê½ƒí™”ë¶„') && !combo.includes('ë¶„í™ê½ƒí™”ë¶„')) {
                            combo.push('ë¶„í™ê½ƒí™”ë¶„', 'ë¶„í™ì”ë””');
                        }
                    } else {
                        combo.push(g);
                        if (g === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') maxSize = 5;
                    }
                }
                
                // ì¡°í•©6,7ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1ë¡œ ì±„ìš°ê¸°
                const availablePool = [...GIMMICKS.normal, ...GIMMICKS.point1].filter(g => !recentGimmicks.includes(g));
                const shuffledPool = shuffleArray(availablePool);
                
                for (const g of shuffledPool) {
                    if (combo.length >= maxSize) break;
                    if (combo.includes(g)) continue;
                    if (!canAddToCombo(combo, g)) continue;
                    
                    combo.push(g);
                    if (g === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') maxSize = 5;
                }
                
                // ë‚¨ì€ ê¸°ë¯¹ì´ ëª¨ë‘ í¬í•¨ë˜ì—ˆëŠ”ì§€ í™•ì¸
                const allRemainingIncluded = remainingGimmicks.every(g => combo.includes(g));
                
                if (combo.length >= 4 && allRemainingIncluded) {
                    return combo;
                }
            }
            
            return null;
        }
        
        // ì¡°í•© 9, 10 ìƒì„±: ìµœê·¼ 2ë ˆë²¨ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1ë§Œ
        function generateComboFromPool(recentGimmicks) {
            for (let attempt = 0; attempt < 100; attempt++) {
                const combo = [];
                let maxSize = 4;
                
                // ìµœê·¼ì— ì—†ëŠ” ë²”ìš©/í¬ì¸íŠ¸1ë§Œ ì‚¬ìš©
                const availablePool = [...GIMMICKS.normal, ...GIMMICKS.point1].filter(g => !recentGimmicks.includes(g));
                const shuffledPool = shuffleArray(availablePool);
                
                for (const g of shuffledPool) {
                    if (combo.length >= maxSize) break;
                    if (combo.includes(g)) continue;
                    if (!canAddToCombo(combo, g)) continue;
                    
                    combo.push(g);
                    if (g === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') maxSize = 5;
                }
                
                if (combo.length >= 4) {
                    return combo;
                }
            }
            
            return null;
        }
        
        // ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì²´í¬ ë° ë¶„ë¦¬
        function checkAndFixYangWoolProximity(blockCombos) {
            // ì–‘í„¸ ë‹¨ë… ì¡°í•©ê³¼ ì–‘í„¸ë°”êµ¬ë‹ˆ+ì–‘í„¸ ì„¸íŠ¸ ì¡°í•© ì°¾ê¸°
            const yangAloneIndices = [];
            const yangWithBasketIndices = [];
            
            blockCombos.forEach((combo, idx) => {
                if (combo.includes('ì–‘í„¸') && !combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ')) {
                    yangAloneIndices.push(idx);
                }
                if (combo.includes('ì–‘í„¸ë°”êµ¬ë‹ˆ') && combo.includes('ì–‘í„¸')) {
                    yangWithBasketIndices.push(idx);
                }
            });
            
            console.log(`ì–‘í„¸ ë‹¨ë… ì¡°í•©: ${yangAloneIndices.length > 0 ? yangAloneIndices.map(i => `ì¡°í•©${i+1}`).join(', ') : 'ì—†ìŒ'}`);
            console.log(`ì–‘í„¸ë°”êµ¬ë‹ˆ+ì–‘í„¸ ì„¸íŠ¸: ${yangWithBasketIndices.length > 0 ? yangWithBasketIndices.map(i => `ì¡°í•©${i+1}`).join(', ') : 'ì—†ìŒ'}`);
            
            // ì¸ì ‘í•œ ê²½ìš° ì°¾ê¸°
            let hasAdjacent = false;
            
            for (const aloneIdx of yangAloneIndices) {
                for (const basketIdx of yangWithBasketIndices) {
                    if (Math.abs(aloneIdx - basketIdx) === 1) {
                        hasAdjacent = true;
                        const earlier = Math.min(aloneIdx, basketIdx);
                        const later = Math.max(aloneIdx, basketIdx);
                        
                        console.log(`\nâš ï¸ ì–‘í„¸ ì¡°í•© ì¸ì ‘ ë°œê²¬:`);
                        console.log(`  ì¡°í•©${earlier+1}: [${blockCombos[earlier].join(', ')}]`);
                        console.log(`  ì¡°í•©${later+1}: [${blockCombos[later].join(', ')}]`);
                        
                        // ì¼€ì´ìŠ¤ 1: ì¡°í•©1ì´ í¬í•¨ëœ ê²½ìš° (ì•ìœ¼ë¡œ ëª» ê°)
                        if (earlier === 0) {
                            console.log(`\në¶„ë¦¬ ë°©ë²•: ì¡°í•©${earlier+1}ì€ ì²« ë²ˆì§¸ â†’ ì¡°í•©${later+1}ì„ 2ì¹¸ ë’¤ë¡œ ì´ë™`);
                            if (later + 2 < blockCombos.length) {
                                const moved = blockCombos.splice(later, 1)[0];
                                blockCombos.splice(later + 2, 0, moved);
                                console.log(`  ì‹¤í–‰: [${moved.join(', ')}]ë¥¼ ì¡°í•©${later+3} ìœ„ì¹˜ë¡œ ì´ë™`);
                            } else {
                                console.log(`  âŒ ì¡°í•©${later+1}ì„ 2ì¹¸ ë’¤ë¡œ ì´ë™ ë¶ˆê°€ (ê³µê°„ ë¶€ì¡±)`);
                                return false;
                            }
                        }
                        // ì¼€ì´ìŠ¤ 2: ì¡°í•©10ì´ í¬í•¨ëœ ê²½ìš° (ë’¤ë¡œ ëª» ê°)
                        else if (later === blockCombos.length - 1) {
                            console.log(`\në¶„ë¦¬ ë°©ë²•: ì¡°í•©${later+1}ì€ ë§ˆì§€ë§‰ â†’ ì¡°í•©${earlier+1}ì„ 2ì¹¸ ì•ìœ¼ë¡œ ì´ë™`);
                            if (earlier - 2 >= 0) {
                                const moved = blockCombos.splice(earlier, 1)[0];
                                blockCombos.splice(earlier - 2, 0, moved);
                                console.log(`  ì‹¤í–‰: [${moved.join(', ')}]ë¥¼ ì¡°í•©${earlier-1} ìœ„ì¹˜ë¡œ ì´ë™`);
                            } else {
                                console.log(`  âŒ ì¡°í•©${earlier+1}ì„ 2ì¹¸ ì•ìœ¼ë¡œ ì´ë™ ë¶ˆê°€ (ê³µê°„ ë¶€ì¡±)`);
                                return false;
                            }
                        }
                        // ì¼€ì´ìŠ¤ 3: ì¼ë°˜ì ì¸ ê²½ìš°
                        else {
                            console.log(`\në¶„ë¦¬ ë°©ë²•: ì¡°í•©${earlier+1}ì„ 1ì¹¸ ì•ìœ¼ë¡œ, ì¡°í•©${later+1}ì„ 1ì¹¸ ë’¤ë¡œ`);
                            
                            // ì•ì˜ ì¡°í•©ì„ ì•ìœ¼ë¡œ swap
                            const temp1 = blockCombos[earlier];
                            blockCombos[earlier] = blockCombos[earlier - 1];
                            blockCombos[earlier - 1] = temp1;
                            console.log(`  ì‹¤í–‰: ì¡°í•©${earlier+1} â†” ì¡°í•©${earlier}`);
                            
                            // ë’¤ì˜ ì¡°í•©ì„ ë’¤ë¡œ swap
                            const temp2 = blockCombos[later];
                            blockCombos[later] = blockCombos[later + 1];
                            blockCombos[later + 1] = temp2;
                            console.log(`  ì‹¤í–‰: ì¡°í•©${later+1} â†” ì¡°í•©${later+2}`);
                        }
                        
                        // ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ ì²´í¬
                        console.log('\nì¬í™•ì¸ ì¤‘...');
                        return checkAndFixYangWoolProximity(blockCombos);
                    }
                }
            }
            
            if (!hasAdjacent) {
                console.log('âœ… ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì—†ìŒ');
            }
            
            return true;
        }
        
        // ë¸”ë¡ ê°„ ì¸ì ‘ ë ˆë²¨ ì²´í¬ ë° êµì²´
        function checkAndFixBlockBoundary(allLevels, currentBlockIdx) {
            const prevBlockNum = currentBlockIdx;
            const currentBlockNum = currentBlockIdx + 1;
            
            console.log(`\n=== ë¸”ë¡ ê²½ê³„ ì²´í¬: ë¸”ë¡${prevBlockNum} <-> ë¸”ë¡${currentBlockNum} ===`);
            
            const prevBlockStart = (currentBlockIdx - 1) * 10;
            const currentBlockStart = currentBlockIdx * 10;
            
            const prevLevel9Num = prevBlockStart + 9;
            const prevLevel10Num = prevBlockStart + 10;
            const currentLevel1Num = currentBlockStart + 1;
            const currentLevel2Num = currentBlockStart + 2;
            
            // ì´ì „ ë¸”ë¡ì˜ ë§ˆì§€ë§‰ 2ê°œ ë ˆë²¨ (ì¡°í•© 9, 10)
            const prevBlock9 = allLevels[prevBlockStart + 8];
            const prevBlock10 = allLevels[prevBlockStart + 9];
            const prevLastTwo = [...prevBlock9, ...prevBlock10];
            
            // í˜„ì¬ ë¸”ë¡ì˜ ì²« 2ê°œ ë ˆë²¨ (ì¡°í•© 1, 2)
            const currentBlock1 = allLevels[currentBlockStart];
            const currentBlock2 = allLevels[currentBlockStart + 1];
            const currentFirstTwo = [...currentBlock1, ...currentBlock2];
            
            console.log(`ë ˆë²¨ ${prevLevel9Num}: [${prevBlock9.join(', ')}]`);
            console.log(`ë ˆë²¨ ${prevLevel10Num}: [${prevBlock10.join(', ')}]`);
            console.log(`ë ˆë²¨ ${currentLevel1Num}: [${currentBlock1.join(', ')}]`);
            console.log(`ë ˆë²¨ ${currentLevel2Num}: [${currentBlock2.join(', ')}]`);
            
            // ì¶©ëŒ ì²´í¬
            const conflicts = currentFirstTwo.filter(g => prevLastTwo.includes(g));
            
            if (conflicts.length === 0) {
                console.log('âœ… ì¶©ëŒ ì—†ìŒ');
                return true;
            }
            
            console.log(`âš ï¸ ì¶©ëŒ ë°œê²¬: [${conflicts.join(', ')}]`);
            console.log(`ë¸”ë¡${currentBlockNum}ì˜ 1,2ë²ˆ ì¡°í•©ì„ 3~10ë²ˆ ì¤‘ì—ì„œ êµì²´ ì‹œë„...`);
            
            // í˜„ì¬ ë¸”ë¡ì˜ 3~10ë²ˆ ì¡°í•© ì¤‘ì—ì„œ êµì²´í•  2ê°œ ì°¾ê¸°
            const candidates = [];
            for (let i = 2; i < 10; i++) {
                const candidateCombo = allLevels[currentBlockStart + i];
                const hasConflict = candidateCombo.some(g => prevLastTwo.includes(g));
                
                if (!hasConflict) {
                    candidates.push(i);
                }
            }
            
            console.log(`êµì²´ ê°€ëŠ¥í•œ ì¡°í•© (ë¸”ë¡${currentBlockNum} ë‚´): [${candidates.map(i => i + 1).join(', ')}]`);
            
            if (candidates.length < 2) {
                console.log('âŒ êµì²´ ê°€ëŠ¥í•œ ì¡°í•©ì´ 2ê°œ ë¯¸ë§Œ');
                return false;
            }
            
            // ì²˜ìŒ 2ê°œ ì„ íƒí•˜ì—¬ êµì²´
            const swap1 = candidates[0];
            const swap2 = candidates[1];
            
            console.log(`êµì²´: ë ˆë²¨${currentLevel1Num}(ì¡°í•©1) â†” ë ˆë²¨${currentBlockStart + swap1 + 1}(ì¡°í•©${swap1 + 1})`);
            console.log(`êµì²´: ë ˆë²¨${currentLevel2Num}(ì¡°í•©2) â†” ë ˆë²¨${currentBlockStart + swap2 + 1}(ì¡°í•©${swap2 + 1})`);
            
            // Swap
            const temp1 = allLevels[currentBlockStart];
            const temp2 = allLevels[currentBlockStart + 1];
            
            allLevels[currentBlockStart] = allLevels[currentBlockStart + swap1];
            allLevels[currentBlockStart + 1] = allLevels[currentBlockStart + swap2];
            
            allLevels[currentBlockStart + swap1] = temp1;
            allLevels[currentBlockStart + swap2] = temp2;
            
            console.log('âœ… êµì²´ ì™„ë£Œ');
            
            // êµì²´ í›„ ì¬í™•ì¸
            const newFirst1 = allLevels[currentBlockStart];
            const newFirst2 = allLevels[currentBlockStart + 1];
            const newFirstTwo = [...newFirst1, ...newFirst2];
            const newConflicts = newFirstTwo.filter(g => prevLastTwo.includes(g));
            
            console.log(`êµì²´ í›„ ë ˆë²¨${currentLevel1Num}: [${newFirst1.join(', ')}]`);
            console.log(`êµì²´ í›„ ë ˆë²¨${currentLevel2Num}: [${newFirst2.join(', ')}]`);
            
            if (newConflicts.length > 0) {
                console.log(`âš ï¸ êµì²´ í›„ì—ë„ ì¶©ëŒ: [${newConflicts.join(', ')}]`);
                return false;
            }
            
            console.log('âœ… êµì²´ í›„ ì¶©ëŒ ì—†ìŒ í™•ì¸');
            
            // Swap í›„ ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì²´í¬ (í˜„ì¬ ë¸”ë¡ë§Œ)
            console.log(`\në¸”ë¡${currentBlockNum} ì–‘í„¸ ì¡°í•© ì¸ì ‘ ì¬ì²´í¬ ì¤‘...`);
            
            // í˜„ì¬ ë¸”ë¡ì˜ ì¡°í•©ë§Œ ì¶”ì¶œ
            const currentBlockCombos = [];
            for (let i = 0; i < 10; i++) {
                currentBlockCombos.push(allLevels[currentBlockStart + i]);
            }
            
            // ì–‘í„¸ ì¸ì ‘ ì²´í¬
            const yangFixed = checkAndFixYangWoolProximity(currentBlockCombos);
            if (!yangFixed) {
                console.log(`âŒ ë¸”ë¡${currentBlockNum} ì–‘í„¸ ì¡°í•© ë¶„ë¦¬ ì‹¤íŒ¨`);
                return false;
            }
            
            // ìˆ˜ì •ëœ ì¡°í•©ì„ ë‹¤ì‹œ allLevelsì— ë°˜ì˜
            for (let i = 0; i < 10; i++) {
                allLevels[currentBlockStart + i] = currentBlockCombos[i];
            }
            
            // Swap í›„ ë¸”ë¡ ë‚´ë¶€ ì¸ì ‘ì„± ì²´í¬ (ìµœê·¼ 2ë ˆë²¨ ë¶„ì‚° ê·œì¹™)
            console.log(`\në¸”ë¡${currentBlockNum} ë‚´ë¶€ ì¸ì ‘ì„± ì²´í¬ ì¤‘...`);
            
            let i = 0;
            let samePositionRetry = 0; // ê°™ì€ ìœ„ì¹˜ ì¬ì‹œë„ ì¹´ìš´í„°
            const maxSamePositionRetry = 20; // ê°™ì€ ìœ„ì¹˜ ìµœëŒ€ ì¬ì‹œë„
            
            while (i < 9) { // ì¡°í•© 1-9ê¹Œì§€ (10ì€ ë‹¤ìŒ ë¸”ë¡ê³¼ ì²´í¬ë¨)
                const levelIdx = currentBlockStart + i;
                const nextLevelIdx = levelIdx + 1;
                
                const currentCombo = allLevels[levelIdx];
                const nextCombo = allLevels[nextLevelIdx];
                
                // ê²¹ì¹˜ëŠ” ê¸°ë¯¹ ì°¾ê¸°
                const overlap = currentCombo.filter(g => nextCombo.includes(g));
                
                if (overlap.length > 0) {
                    console.log(`âš ï¸ ë ˆë²¨${levelIdx + 1} â†” ë ˆë²¨${nextLevelIdx + 1} ì¶©ëŒ: [${overlap.join(', ')}]`);
                    
                    // ê°™ì€ ìœ„ì¹˜ì—ì„œ ë„ˆë¬´ ë§ì´ ì¬ì‹œë„í•˜ë©´ ë¸”ë¡ ì¬ìƒì„±
                    if (samePositionRetry >= maxSamePositionRetry) {
                        console.log(`âŒ ë ˆë²¨${levelIdx + 1}-${nextLevelIdx + 1} ì¬ì‹œë„ í•œê³„ ì´ˆê³¼ (${maxSamePositionRetry}ë²ˆ)`);
                        return false;
                    }
                    
                    console.log(`  ë ˆë²¨${nextLevelIdx + 1}ì—ì„œ ì¶©ëŒ ê¸°ë¯¹ êµì²´... (ì¬ì‹œë„ ${samePositionRetry + 1}/${maxSamePositionRetry})`);
                    
                    // ì¶©ëŒí•˜ëŠ” ê¸°ë¯¹ë§Œ êµì²´
                    if (!replaceConflictingGimmicks(allLevels, nextLevelIdx, overlap)) {
                        console.log(`  âŒ ë ˆë²¨${nextLevelIdx + 1} ì¶©ëŒ ê¸°ë¯¹ êµì²´ ì‹¤íŒ¨`);
                        return false;
                    }
                    
                    // êµì²´ í›„ ê°™ì€ ì¸ë±ìŠ¤ë¥¼ ë‹¤ì‹œ ì²´í¬ (êµì²´í•œ ê¸°ë¯¹ë„ ì¶©ëŒí•  ìˆ˜ ìˆìŒ)
                    console.log(`  ë ˆë²¨${levelIdx + 1} â†” ë ˆë²¨${nextLevelIdx + 1} ì¬í™•ì¸...`);
                    samePositionRetry++;
                    continue; // whileë¬¸ ì²˜ìŒë¶€í„° (iëŠ” ê·¸ëŒ€ë¡œ)
                }
                
                // ì¶©ëŒ ì—†ìœ¼ë©´ ë‹¤ìŒìœ¼ë¡œ
                i++;
                samePositionRetry = 0; // ìœ„ì¹˜ ì´ë™ ì‹œ ì¹´ìš´í„° ë¦¬ì…‹
            }
            
            console.log('âœ… ë¸”ë¡ ë‚´ë¶€ ì¸ì ‘ì„± ì²´í¬ ì™„ë£Œ');
            return true;
        }
        
        // 4ë‹¨ê³„: 4-ì¡°í•© ì¤‘ë³µ ì²´í¬ ë° ë ˆë²¨ ì¬ìƒì„±
        function checkAndReplaceDuplicatesWithBlockInfo(allLevels) {
            const comboMap = new Map();
            const duplicates = [];
            
            // ì¤‘ë³µ ì°¾ê¸°
            allLevels.forEach((combo, idx) => {
                const key = combo.slice().sort().join('|');
                if (comboMap.has(key)) {
                    duplicates.push(idx); // ë’¤ì— ë‚˜ì˜¨ ê²ƒë§Œ ì¶”ê°€
                } else {
                    comboMap.set(key, idx);
                }
            });
            
            if (duplicates.length === 0) {
                console.log('âœ… ì¤‘ë³µ ì—†ìŒ');
                return { success: true, levels: allLevels };
            }
            
            console.log(`âš ï¸ ì¤‘ë³µ ë°œê²¬: ${duplicates.length}ê°œ ë ˆë²¨ (${duplicates.map(i => i + 1).join(', ')})`);
            
            // ì¤‘ë³µëœ ë ˆë²¨ë“¤ì´ ì†í•œ ë¸”ë¡ ì •ë³´ ì¶œë ¥
            const duplicateBlocksInfo = new Map();
            duplicates.forEach(dupIdx => {
                const blockIdx = Math.floor(dupIdx / 10);
                if (!duplicateBlocksInfo.has(blockIdx)) {
                    duplicateBlocksInfo.set(blockIdx, []);
                }
                duplicateBlocksInfo.get(blockIdx).push(dupIdx + 1);
            });
            
            console.log('ì¤‘ë³µ ë ˆë²¨ì´ ì†í•œ ë¸”ë¡:');
            duplicateBlocksInfo.forEach((levels, blockIdx) => {
                console.log(`  ë¸”ë¡ ${blockIdx + 1} (ë ˆë²¨ ${blockIdx*10+1}-${blockIdx*10+10}): ë ˆë²¨ ${levels.join(', ')}`);
            });
            
            // ì¤‘ë³µëœ ë ˆë²¨ë“¤ ì¬ìƒì„±
            console.log('\nì¤‘ë³µëœ ë ˆë²¨ ì¬ìƒì„± ì‹œë„...');
            
            for (const dupIdx of duplicates) {
                console.log(`\në ˆë²¨ ${dupIdx + 1} ì¬ìƒì„± ì¤‘...`);
                
                // ìµœëŒ€ 20ë²ˆ ì‹œë„
                let regenerateSuccess = false;
                for (let attempt = 0; attempt < 20; attempt++) {
                    // ì´ì „ ì¡°í•© í‚¤ ì œê±°
                    const oldKey = allLevels[dupIdx].slice().sort().join('|');
                    if (comboMap.get(oldKey) === dupIdx) {
                        comboMap.delete(oldKey);
                    }
                    
                    // ì¬ìƒì„±
                    if (regenerateLevel(allLevels, dupIdx, comboMap)) {
                        regenerateSuccess = true;
                        break;
                    }
                }
                
                if (!regenerateSuccess) {
                    console.log(`âŒ ë ˆë²¨ ${dupIdx + 1} ì¬ìƒì„± ì‹¤íŒ¨`);
                    
                    // ì‹¤íŒ¨í•œ ë ˆë²¨ì´ ì†í•œ ë¸”ë¡ ë°˜í™˜ (ë¸”ë¡ ì¬ìƒì„±ìš©)
                    const failedBlocks = Array.from(duplicateBlocksInfo.keys());
                    return { 
                        success: false, 
                        duplicateBlocks: failedBlocks
                    };
                }
            }
            
            console.log('\nâœ… ëª¨ë“  ì¤‘ë³µ ë ˆë²¨ ì¬ìƒì„± ì™„ë£Œ');
            return { success: true, levels: allLevels };
        }
        
        // 4ë‹¨ê³„: 4-ì¡°í•© ì¤‘ë³µ ì²´í¬ ë° êµì²´ (ê¸°ì¡´ í•¨ìˆ˜ - í˜¸í™˜ì„± ìœ ì§€)
        function checkAndReplaceDuplicates(allLevels) {
            const result = checkAndReplaceDuplicatesWithBlockInfo(allLevels);
            return result.success ? result.levels : null;
        }
        
        function generateReplacementCombo(gimmicks, existingCombos) {
            const shuffled = shuffleArray(gimmicks);
            const combo = [];
            const used = new Set();
            let maxSize = 4;
            
            for (let i = 0; i < shuffled.length && combo.length < maxSize; i++) {
                if (used.has(i)) continue;
                
                const current = shuffled[i];
                if (combo.includes(current)) continue;
                if (!canAddToCombo(combo, current)) continue;
                
                combo.push(current);
                used.add(i);
                
                if (current === 'í­íƒ„ì£¼ë¨¸ë‹ˆ') maxSize = 5;
            }
            
            if (combo.length < 4) return null;
            
            // ì¤‘ë³µ ì²´í¬
            const key = combo.slice().sort().join('|');
            if (existingCombos.has(key)) return null;
            
            return combo;
        }
        
        function displayCompositionResult(levels, stats) {
            const container = document.getElementById('compositionResult');
            let html = '<div class="composition-levels">';
            
            // 10ê°œ ë¸”ë¡ (ê° 5ê°œ ë ˆë²¨ì”©)
            for (let block = 0; block < 10; block++) {
                html += '<div class="level-grid">';
                for (let i = 0; i < 5; i++) {
                    const levelIdx = block * 5 + i;
                    if (levelIdx < levels.length) {
                        html += `<div class="level-card">
                            <div class="level-header">${levelIdx + 1}</div>`;
                        levels[levelIdx].forEach(g => {
                            html += `<div class="level-gimmick">${g}</div>`;
                        });
                        html += '</div>';
                    }
                }
                html += '</div>';
            }
            
            html += '</div>';
            
            // í†µê³„ ê³„ì‚°
            const sortedStats = Object.entries(stats).sort((a, b) => b[1] - a[1]);
            const most = sortedStats.slice(0, 5);
            
            // ë¸”ë¡ë³„ ì‚¬ìš© íšŸìˆ˜ ê³„ì‚°
            const blockStats = Array(5).fill(0).map(() => ({}));
            const allGimmicks = [...GIMMICKS.point1, ...GIMMICKS.point2, ...GIMMICKS.normal];
            allGimmicks.forEach(g => {
                blockStats.forEach(block => block[g] = 0);
            });
            
            levels.forEach((level, idx) => {
                const blockIdx = Math.floor(idx / 10);
                level.forEach(g => {
                    blockStats[blockIdx][g]++;
                });
            });
            
            // ë ˆë²¨ ìœ„ì¹˜ ê³„ì‚°
            const levelPositions = {};
            allGimmicks.forEach(g => levelPositions[g] = []);
            
            levels.forEach((level, idx) => {
                level.forEach(g => {
                    levelPositions[g].push(idx + 1);
                });
            });
            
            html += '<div class="stats-section">';
            html += '<div class="stats-title">ê¸°ë¯¹ ì‚¬ìš© í†µê³„</div>';
            
            // ê°€ì¥ ë§ì´ ë“±ì¥í•œ ê¸°ë¯¹
            html += '<div class="stats-highlight"><div class="stats-highlight-title">ê°€ì¥ ë§ì´ ë“±ì¥í•œ ê¸°ë¯¹</div>';
            html += '<div class="stats-highlight-grid">';
            most.forEach(([name, count]) => {
                html += `<div class="stat-card most">
                    <div class="stat-name">${name}</div>
                    <div class="stat-count">${count}</div>
                </div>`;
            });
            html += '</div></div>';
            
            // ì „ì²´ ê¸°ë¯¹ ë“±ì¥ íšŸìˆ˜
            html += '<div class="all-stats"><div class="all-stats-title">ì „ì²´ ê¸°ë¯¹ ë“±ì¥ íšŸìˆ˜</div>';
            html += '<div class="all-stats-grid">';
            sortedStats.forEach(([name, count]) => {
                html += `<div class="all-stat-item">
                    <div class="all-stat-name">${name}</div>
                    <div class="all-stat-count">${count}íšŒ</div>
                </div>`;
            });
            html += '</div></div>';
            
            // ë¸”ë¡ë³„ ì‚¬ìš© íšŸìˆ˜
            html += '<div class="block-stats" style="margin-top: 40px;">';
            html += '<div class="all-stats-title" style="font-size: 19px; font-weight: 700; color: #1a1a1a; margin-bottom: 20px;">ë¸”ë¡ë³„ ê¸°ë¯¹ ì‚¬ìš© íšŸìˆ˜</div>';
            
            for (let blockIdx = 0; blockIdx < 5; blockIdx++) {
                const blockStart = blockIdx * 10 + 1;
                const blockEnd = blockIdx * 10 + 10;
                html += `<div style="margin-bottom: 30px; padding: 20px; background: white; border-radius: 8px; border: 1px solid #e5e5e5;">`;
                html += `<div style="font-weight: 700; color: #004B3E; margin-bottom: 15px; font-size: 16px;">ë¸”ë¡ ${blockIdx + 1} (ë ˆë²¨ ${blockStart}-${blockEnd})</div>`;
                html += '<div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; font-size: 14px;">';
                
                const blockGimmicks = Object.entries(blockStats[blockIdx])
                    .filter(([name, count]) => count > 0)
                    .sort((a, b) => b[1] - a[1]);
                
                blockGimmicks.forEach(([name, count]) => {
                    html += `<div style="padding: 8px; background: #f8f9fa; border-radius: 4px; text-align: center;">
                        <div style="color: #666; font-size: 13px;">${name}</div>
                        <div style="font-weight: 700; color: #004B3E; margin-top: 4px;">${count}íšŒ</div>
                    </div>`;
                });
                
                html += '</div></div>';
            }
            html += '</div>';
            
            // ë ˆë²¨ ìœ„ì¹˜
            html += '<div class="level-positions" style="margin-top: 40px;">';
            html += '<div class="all-stats-title" style="font-size: 19px; font-weight: 700; color: #1a1a1a; margin-bottom: 20px;">ê° ê¸°ë¯¹ ë“±ì¥ ë ˆë²¨</div>';
            
            sortedStats.forEach(([name, count]) => {
                if (count > 0) {
                    html += `<div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e5e5e5;">`;
                    html += `<div style="font-weight: 700; color: #004B3E; margin-bottom: 8px; font-size: 15px;">${name} (${count}íšŒ)</div>`;
                    html += `<div style="color: #666; font-size: 14px; line-height: 1.8;">`;
                    html += levelPositions[name].join(', ');
                    html += '</div></div>';
                }
            });
            
            html += '</div>';
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // íƒ­ ì „í™˜
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            const scrollBtns = document.querySelectorAll('.scroll-btn');
            if (tabName === 'composition' || tabName === 'shuffle') {
                scrollBtns.forEach(btn => btn.style.display = 'block');
                updateScrollButtons();
            } else {
                scrollBtns.forEach(btn => btn.style.display = 'none');
            }
        }
        
        // ìŠ¤í¬ë¡¤ ë²„íŠ¼
        function scrollToTop() {
            window.scrollTo({top: 0, behavior: 'smooth'});
        }
        
        function scrollToBottom() {
            window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});
        }
        
        function updateScrollButtons() {
            const scrollTop = document.querySelector('.scroll-top');
            const scrollBottom = document.querySelector('.scroll-bottom');
            
            if (window.scrollY > 300) {
                scrollTop.style.display = 'block';
            } else {
                scrollTop.style.display = 'none';
            }
            
            if (window.scrollY < document.body.scrollHeight - window.innerHeight - 300) {
                scrollBottom.style.display = 'block';
            } else {
                scrollBottom.style.display = 'none';
            }
        }
        
        window.addEventListener('scroll', updateScrollButtons);
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ëœë¤ ìƒì„±
        window.addEventListener('load', () => {
            generateRandom();
        });
    </script>
</body>
</html>
